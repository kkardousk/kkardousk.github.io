{
  "hash": "f9688c2eeb873529ba4a3d90d265c370",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: |\n  <div class=\"custom-title-block\" style=\"text-align: center;\">\n    <span style=\"color:#2c3e50; font-size: 1.4em; font-weight: bold;\">Exploring Inversions using Python</span><br>\n    <span style=\"font-size:.5em;\">Karim K. Kardous</span><br>\n    <a href=\"mailto:kardouskarim@gmail.com\" style=\"margin: 0 6px; font-size: 0.9em;\">\n      <i class=\"bi bi-envelope\"></i>\n    </a>\n    <a href=\"https://github.com/kkardousk\" style=\"margin: 0 6px; font-size: 0.9em;\">\n      <i class=\"bi bi-github\"></i>\n    </a>\n  </div>\nformat:  \n  html:\n    toc: true\n    toc-depth: 4\n    toc-expand: true\n    toc-title: 'Jump To'\n    number-depth: 2\n    fig-format: retina\n    fig-dpi: 300\n    code-link: true # requires both downlit and xml2 to be downloaded\n    code-fold: true\n    code-summary: '<i class=\"bi-code-slash\"></i> Show the code'\n    # code-overflow: wrap\n    code-tools:\n      toggle: true  # adds \"Show All / Hide All\"; also allows for all code copy (at once as quarto doc)\n    css: styles.css\n    highlight-style: github-dark\n    df-print: paged\n    page-layout: article\n    embed-resources: true\n    smooth-scroll: true\n    link-external-icon: false\n    link-external-newwindow: true\n    fontsize: 1.1em\n    linestretch: 0\n    linespace: 0\n    html-math-method: katex\n    linkcolor: '#D35400'\nexecute:\n  echo: true\n  warning: false\n  message: false\n  info: false\n  cache: false\n  freeze: auto\neditor: visual\n---\n\n\n\n\n\n## **Initial Setup**\n\n::: text-justify\nI start by configuring the Python environment using `{reticulate}`, specifying a custom virtual environment and ensuring required packages (matplotlib and pillow) are installed. This setup step ensures Python and R work seamlessly together; granted 'seamlessly' might be over-reaching, but at least for this case, fairly commonly used modules, it was the case.\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(reticulate)\ninvisible(\n  capture.output({\n    Sys.setenv(RETICULATE_PYTHON = \"py_venv/bin/python3.9\")\n    reticulate::use_python(\"py_venv/bin/python3.9\", required = TRUE)\n    })\n)\n\ninvisible(\n  capture.output({\n  use_python(\"py_venv/bin/python3.9\", required = TRUE)\n  py_config()\n  py_install(c('matplotlib', 'pillow'), envname = \"py_venv\", pip = TRUE)\n  })\n)\n```\n:::\n\n\n\n\n\n::: text-justify\nWith this chunk executed, R is now ready to run Python code from the designated virtual environment with the necessary libraries installed.\n:::\n\n## **Image Configuration and Setup using matplotlib & [Pillow](https://pypi.org/project/pillow/)**\n\n::: text-justify\nTo overcome issues with displaying Pillow images directly in Quarto, I used matplotlib.pyplot to render and show images in the document. This section defines utility functions for drawing images programmatically, including a basic black board, a chessboard, and an inversion-based pattern. Otherwise, you'd likely have to set figure parameters such as dimensions, axes, etc. for every image input, so I create the below function to reduce/eliminate this redundancy.\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom PIL import Image \nimport matplotlib.pyplot as plt\nimport math\n\n# build a function to ease the plotting, reusable boilerplate basically with option to add additional arguments\ndef draw_figure(width=512, height=512, draw_func=None, title='Custom Board', figsize=(4, 4), background='white', **kwargs):\n    \n    board = Image.new('RGB', (width, height), background) \n    # apply function if provided\n    if draw_func:\n        draw_func(board, width, height, **kwargs)\n    \n    plt.figure(figsize=figsize)\n    plt.imshow(board)\n    plt.axis('off')\n    plt.title(title)\n    plt.show()\n    \n  \ndef solid_unicolor_board(board, width, height):\n  \n  for x in range(width):\n    for y in range(height):\n      board.putpixel( (x, y), (0, 0, 0))\n\n# define chess board pattern\ndef chess_pattern(board, width, height, square = 64, **kwargs):\n  \n  for x in range(width):\n    for y in range(height):\n      cx = x // square # or you can use math.floor(x / square) if index doesn't jstart at 0 \n      cy = y // square\n      color = ((cx + cy) % 2) * 255\n      board.putpixel((x, y), (color, color, color)) # black and white\n      \n# define an inversion \ndef inversion_pattern(board, width, height, R = 256, square = 64, **kwargs):\n\n  for x in range(width):\n    for y in range(height):\n      x0 = x - width / 2 + 0.5  # define a center for x and one for y with offsets by half a pixel as technically the center is at .5, .5\n      y0 = y - height / 2 + 0.5\n      f = R**2 / (x0**2 + y0**2) # inverse factor or the radius squared divided by distance to center; addition to avoid zero division\n      x1 = x0 * f\n      y1 = y0 * f\n      cx = math.floor(x1 / square)\n      cy = math.floor(y1 / square)\n      color = ((cx + cy) % 2) * 255\n      # board.putpixel((x, y), (color, color, 0)) # black and yellow  \n      board.putpixel((x, y), (color, color, color)) # black and white  \n\n# outputting results/images\ndraw_figure(\n  draw_func = solid_unicolor_board,\n  title = 'Solid Black Board'\n  )\n```\n\n::: {.cell-output-display}\n![](inversions_py_files/figure-html/unnamed-chunk-2-1.png){width=384}\n:::\n\n```{.python .cell-code}\ndraw_figure(\n  draw_func = chess_pattern, \n  title = 'Chess Board'\n  )\n```\n\n::: {.cell-output-display}\n![](inversions_py_files/figure-html/unnamed-chunk-2-2.png){width=384}\n:::\n\n```{.python .cell-code}\n  \ndraw_figure(\n  draw_func = inversion_pattern, \n  square = 256, \n  title = 'Initial inversion Board'\n  )\n```\n\n::: {.cell-output-display}\n![](inversions_py_files/figure-html/unnamed-chunk-2-3.png){width=384}\n:::\n:::\n\n\n\n\n\n::: text-justify\nThe closer you get to the center, the more stretched and squished things become visually (that's if you really zoom it). This also explains why some areas look pixelated - the image doesnâ€™t have enough detail at this size to show everything smoothly so next resolution is improved.\n:::\n\n## **Improving Output Resolution**\n\n::: text-justify\nTo reduce the pixelation, especially towards the center of the image, I increase both the image dimensions and the square size; essentially increase resolution.\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndraw_figure(\n  draw_func = inversion_pattern, \n  width = 512 * 2, \n  height = 512 * 2, \n  square = 256 * 2, \n  R = 256 * 2, \n  title = 'Improved Resolution (x2)'\n  )\n```\n\n::: {.cell-output-display}\n![](inversions_py_files/figure-html/unnamed-chunk-3-7.png){width=384}\n:::\n:::\n\n\n\n\n\n::: text-justify\nDoubling the dimensions already leads to significant visual improvement. The lift in clarity is again specially visible towards the center/origin where distortion is most intense/visible.\n:::\n\n## **Improving Output Resolution (by a factor of 10)**\n\nIncreasing resolution tenfold didn't slow down render time that much so I go for it and it does look like we win in the trade.\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndraw_figure(\n  draw_func = inversion_pattern, \n  width = 512 * 10, \n  height = 512 * 10, \n  square = 256 * 10, \n  R = 256 * 10, \n  title = 'Final Inversion - Improved Resolution (x10)'\n  )\n```\n\n::: {.cell-output-display}\n![](inversions_py_files/figure-html/unnamed-chunk-4-9.png){width=384}\n:::\n:::\n\n\n\n\n\nOverall, I thought it was interesting, aesthetically if nothing else, to see how with a few lines of code, fairly intricate and cool-looking images get created. Thanks for reading !\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}